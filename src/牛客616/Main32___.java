package 牛客616;

/**
 * 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。
 * 
 * @author Chan
 *
 */
public class Main32___ {
	/**
	 * 
	 * 举个例子就明白了：n=150；
	 * 包含1的数由三部分组成：个位数字是1，如1,11,21,31,41,51,61,71,81,91,101,111,121,131,141共15个
	 * 十位数字是1，如10,11,12,13,14,15,16,17,18,19,110,111,112,113,114,115,116,117,118,119共20个
	 * 百位数字是1，如100-150共51个 总共86个，其中11有两个1，计数时分别记录个位1次，十位1次，不矛盾 那怎么计算那个位上到底有多少1呢？
	 * 根据n又分三种情况：
	 * 该位是0；（比如分析150的个位数字0，1-150之间的数个位是1的根据比0高的位计算，看1,11,21,31,41,51,61,71,81,91,101,111,121,131,141这些数的特点就可以得到）
	 * 该位是1；（比如150的百位数字1，推算0-150间百位数字是1的个数由比百位更高的位和比百位低的位决定，这个例子不是很好找这个，可以换一个例子）
	 * 该位大于1；（由高位决定，可以自己尝试找到规律） 总之，这个题关键的一点就是分析哪个位就找哪个位是1的个数
	 * 
	 * 也可以用一个StringBuilder把所有数字加起来，计算1个数...
	 */
	public int NumberOf1Between1AndN_Solution(int n) {
		int ones = 0;
		int a = 0;
		for (int m = 1; m <= n; m *= 10) {
			a = n / m;
			if (a % 10 == 0)
				ones += a / 10 * m;
			else if (a % 10 == 1)
				ones += (a / 10 * m) + (n % m + 1);
			else
				ones += (a / 10 + 1) * m;
		}
		return ones;
	}

	public static void main(String[] args) {
		int i = new Main32___().NumberOf1Between1AndN_Solution(201);
		System.out.println(i);
	}
}
